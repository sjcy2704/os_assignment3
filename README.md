## Assignment 3 Concurrent Merge Sort 

- Authors: Steven Jack Chung Yau and Niyatiben Patel
- Group name: UG Group 4

## Overview

The program create multiple threads that will perform the merge sort algorithm in
subarrays of the main array. Multiple threads are used to increase the
performance of the algorithm by parallelizing it in each subarray.

## Manifest

A listing of source files and other non-generated files, and a brief
(one-line) explanation of the purpose of each file.

- Makefile: contains instructions on how to compile the project by running `make` on the terminal.
- mergesort.h: header file containing the interface of the methods used for the
  algorithm.
- mergesort.c: implementation of the methods from the header file `megersort.h`
- test-mergesort.c: creates an array randomly to test the algorithm and showing
  how long it takes.

## Building the project

To build the project is as easy as running a single command:

```bash
make
```

As said before, the Makefile already contains the instructions to compile the
project.

However, each time you make changes to the program you have to remove the
compiled files or you can easily do it by running the command:

```bash
make clean
```

## Features and usage

The program create an `x` amount of threads and each thread will perform merge
sort on a range of elements of the array and it will continue dividing (creating
threads) up until the cutoff level.

Each level is an exponential number of threads. For example:

```text
cutoff-level: n threads
0: 1 thread
1: 2 threads
2: 4 threads
3: 8 threads
4: 16 threads
...
```

It already includes a script `test-mergesort` to test the algorithm and parallelization based on the level set.

The script has 3 arguments that are needed the `number of elements`, the `cutoff level`, and a `seed (for the randomization of elements)`.

- the `number of elements` is just how many random numbers you want to be
  generated by the random generator.
- The `cutoff level` can only reach to a certain point before it loses the
  performance slightly.
- The `seed` can be any number. This will help the random generator be truly
  random based on the seed.

```bash
# ./test-mergesort <number-of-elements> <cutoff-level> <seed>
# e.g.

./test-mergesort 100000000 4 1234
```

## Testing

This section should detail how you tested your code. Simply stating "I ran
it a few times and it seems to work" is not sufficient. Your testing needs
to be detailed here.

The way it was tested it was indeed by running the program. However, we had to
make sure it was doing what it is supposed to do which is halving the time it
takes to sort at each level.

We tested the program by the script and generating a 100 million numbers with a
cutoff level from 0-10 and a random number as the seed.

```bash
❯ ./test-mergesort 100000000 0 1857983
Sorting 100000000 elements took 15.43 seconds.
❯ ./test-mergesort 100000000 1 1857983
Sorting 100000000 elements took 7.98 seconds.
❯ ./test-mergesort 100000000 2 1857983
Sorting 100000000 elements took 4.25 seconds.
❯ ./test-mergesort 100000000 3 1857983
Sorting 100000000 elements took 2.68 seconds.
❯ ./test-mergesort 100000000 4 1857983
Sorting 100000000 elements took 2.34 seconds.
❯ ./test-mergesort 100000000 5 1857983
Sorting 100000000 elements took 2.43 seconds.
❯ ./test-mergesort 100000000 6 1857983
Sorting 100000000 elements took 2.30 seconds.
❯ ./test-mergesort 100000000 7 1857983
Sorting 100000000 elements took 2.28 seconds.
❯ ./test-mergesort 100000000 8 1857983
Sorting 100000000 elements took 2.29 seconds.
❯ ./test-mergesort 100000000 9 1857983
Sorting 100000000 elements took 2.29 seconds.
❯ ./test-mergesort 100000000 10 1857983
Sorting 100000000 elements took 2.28 seconds
```

As you can see from the pasted results above, it takes around 15 seconds to sort 100
million numbers when the cutoff level is 0 meaning that its not using
parallelization so sequential merge sorting. And as the cutoff level is
increased, the time gets halved. However, after level 5 we can see that the
performance doesn't increase anymore because regardless of how many threads you
have is still 100 million numbers.

## Reflection and Self Assessment

We consider that the assignment was really straightforward. Create new threads
for each leg (left and right subarrays) until it reaches the cutoff level and
then perform merge sort in those. And if the cutoff level is 0, perform merge
sort directly.

After inspecting the `test-mergesort.c`, it was also clear that the main
function called to perform the algorithm was `parallel_mergesort`. Which hinted
us that this function is going to handle when to create threads, when to stop
creating them, and when to perform the algorithm. 

However, although it was straightforward, it didn't mean that we knew how to code
the algorithm. We touched on it during our other courses (ADDS and ADSA) but we
never implemented it. So we needed a refresher for it and how to implement it.
We used a pretty famous website that teaches you about algorithms and
development in general and that was GeeksForGeeks. It helped us understand once
again how merge sort worked and we also learned how it was implemented in their
website. Aside from GeeksForGeeks, we also used the resources given in the
assignment description.

In terms of dealing with the threads, we didn't have a lot of issue since it was
clearly explained in the assignment description as well.

We had a few errors when running the program. One of them was that we didn't
implement the cutoff properly (simple mistake missing a return) so it would
continue to generate new threads until the computer just crashed. It was fixed
by adding a return in the cutoff condition lol. 

Another error we had was that the program gets aborted because it was trying to
free a variable that was not allocated meaning that it didn't exists. The issue
was that after casting the `arg` parameter to a `struct argument` because `arg`
was void, we were freeing the casted pointer variable after each merge so it
would repeatedly try to free the variable when it was already freed. We fixed it
by just freeing the children arguments (arguments for each left and right leg)
and not freed the casted pointer variable as the `arg` variable was already
being freed by the `test-mergesort.c` main function.

Overall, the development was relatively smooth and straight. I must say that its
thanks to the assignment description as it had a lot of details and answers to
questions people may have during the development of the program. 

## Sources Used

GeeksforGeeks 2025. Merge Sort. [online] Available at: https://www.geeksforgeeks.org/dsa/merge-sort/
 [Accessed 28 Oct 2025].

HackerRank 2016. Algorithms: Merge Sort [YouTube video]. [online] Available at: https://www.youtube.com/watch?v=KF2j-9iSf4Q
 [Accessed 28 Oct 2025].

GeeksforGeeks 2025. Thread Management Functions in C. [online] Available at: https://www.geeksforgeeks.org/c/thread-functions-in-c-c/
 [Accessed 29 Oct 2025].
